#define VexNUM 15;   
#define EdgeNUM 105;
bool visited[NUM];
int dfn[NUM];
int counter  = 1;
typedef union
{
 int idata;
 char cdata;
}Data;
typedef struct      //有向图的十字链表表示法
{
 Data data;
 EdgeNode * firstin ,firstout;
}HeadNode;
typedef struct
{
 int tail,head;
 EdgeNode * next,headofj; 
}EdgeNode;
typedef struct       //邻接表表示图
{
 int vexnum;
 int edgenum;
 HeadNode[VexNUM];
 EdgeNode[EdgeNUM];
}Graph1 ;
typedef struct      //邻接矩阵表示图 
{
 int vexnum;
 int edgenum;
 int vex[VexNUM];
 int edge[VexNUM][VexNUM];
}Graph2 ;
typedef struct 
{
 int front=0,rear=0; 
 int queue[VexNUM];
}Queue;
 
 

void MakeNull(Queue *q)
{
 q->front = q->rear = 0;
} 
int IsEmpty(Queue * q)
{
 return ( p->front == p->rear ); 
}
void EnQueue(Queue * q,int i)
{
 q.queue[front] = i;
 front ++;  
}
void DeQueue()
{
 front --;
}
void DFSTravel(Grsph * G)
{
     int i = 0;
     for(i = 0;i < G.n ; i ++)
 {
  visited[i] = FALSE;
 }
 for(i = 0;i < G.n ; i ++)
 {
  if(!visited[i]) 
   DFS1(G,i);
 }
    return ;
}
void DFS1(Graph *G,int i)     //先深搜索 邻接表存储结构 的有向图或无向图  
{
 EDGELIST *p ;
 cout <<  ;
 dfn[i] = counter ++;
 visited[i] = TRUE;
 p = G.firstout;
 while(p)
 {
  if(!visited[p.headvex])
   DFS1[G,p.headvex];
  p = p -> next;
 }
}
void DFS2(Graph *G,int i)    //先深搜索 邻接矩阵存储结构 的有向图或无向图  
{
 int j;
 cout <<  ;
 dfn[i] = counter ++;
 visited[i] = TRRUE;
 for(j=0 ;j < G.n;j ++)
 {
  if( 1 == edge[i][j] && FALSE == visited[j] )
   DFS2(G,j);
 }
}
void BFSTravel(Graph * G)
{
 int i;
 for(i = 0;i < G.n ; i ++)
 {
  visited[i] = FALSE;
 }
 for(i = 0;i < G.n ; i ++)
 {
  if(!visited[i])
   BFS1(G,i);
 }
        return ;
}
void BFS1(Graph1 * G , int i)
{
 Queue q,*pointq = &q;
 EdgeNode * p;
 while( )
 cout <<  ;
 visited[i] = TRUE;
 EnQueue(pointq,i);
 p = G -> vexlist[i];
 while( p )
 {
  
}